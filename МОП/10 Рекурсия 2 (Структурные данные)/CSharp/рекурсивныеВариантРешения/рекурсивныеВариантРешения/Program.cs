using System;
using System.IO;

namespace рекурсивныеВариантРешения
{
    /*
     *  Дан линейный массив A[1..N], содержащий целые числа.
     *  Выделить те элементы этого массива в массив B, индексы которых являются степенями числа C.
     *    Спецификация ввода	:
     *      N С
     *      Значения элементов массива А по одному в строке
     *    Спецификация вывода	:
     *      Значения элементов массива В в строку через пробел 
     *      
     */
    class Program
    {
        static StreamReader ФайлIn = new StreamReader("inlet.in");
        static StreamWriter ФайлOut = new StreamWriter("outlet.out");
        static void Main(string[] args)
        {
            int N, C;
            int[] A, B;
            вводДанных(out N, out C, out A);
            формированиеМассива(C, A, out B);
            выводРезультата(B);
        }
        /*
         *   1.1. Ввод строки значений N и C
         *   1.2. Преобразование введенных значений в числовой формат
         *   1.3. Резервирование паямяти под массив А
         *   2. Цикл поэлементного ввода элементов массива А
         *   3. Закрытие файла
         */
        static void вводДанных(out int N, out int C, out int[] A)
        {
            string строкаВвода = ФайлIn.ReadLine();
            string[] аргумент = строкаВвода.Split(' ');
            N = Convert.ToInt16(аргумент[0]);
            C = Int16.Parse(аргумент[1]);
            A = new int[N];            
            вводКонвертированиеТипаДанных(0, N, ref A);
            ФайлIn.Close();
        }
        static void вводКонвертированиеТипаДанных(int i, int N, ref int[] A)
        {
            if (i < N)
            {
                string число = ФайлIn.ReadLine();
                A[i] = Int16.Parse(число);
                вводКонвертированиеТипаДанных(i + 1, N, ref A);
            }
        }
        /*    1.1. Наша задача найти такой показатель k, что c^k = N. 
         *       Если прологорифмировать последнее "равенство" по основанию с, то получим log_с(N) = k.
         *       Поскольку речь идет только о целочисленных результатах (индексах), то надо брать 
         *       целую часть частного + 1.
         *    1.2 Резервирование места под элементы массива-результата
         *  2. Цикл по количеству элементов вектора-результата
         *    2.1 Вычисления очередного индекса элемента массива-источника
         *    2.2 Копирование элемента массива-источника в элемент массива-результата
         */
        static void формированиеМассива(int C, int[] A, out int[] B)
        {
           // int k = C == 1 ? 1 : (int)Math.Floor(Math.Log(A.Length, C)) + 1;
            int k = C == 1 ? 1 : размерВ(C, A.Length);
            B = new int[k];
            формированиеВыходногоМассива(0, C, A, ref B);
        }
        static int размерВ(int C, int N)
        {
            return C > 1 ? накопитель(C, N, 1) : 1;
        }
        static int накопитель(int C, int N, int степеньС)
        {
            return степеньС < N ? 1 + накопитель(C, N, C * степеньС) : 0;
        }
        static void формированиеВыходногоМассива(int i, int C, int[] A, ref int[] B)
        {
            if (i < B.Length)
            {
                int j = (int)Math.Pow(C, i);
                B[i] = A[j - 1];
                формированиеВыходногоМассива(i + 1, C, A, ref B);
            }
        }
        /* 1 Инициализация строки вывода
         * 2 Цикл добавления ("приклеивания")
         *   к строке вывода очередного разделительного пробела
         *   и значения очередного элемента результата
         *  3 Уделение из строки вывода начального (конечного) 
         *   пробела
         *  4 Операции вывода в файл и его (файла) закрытие 
         */
        static void выводРезультата(int[] B)
        {
            string строкаВывода = "";            
            формированиеСтрокиВывода(0, B, ref строкаВывода);
            строкаВывода = строкаВывода.Trim();
            ФайлOut.Write(строкаВывода);
            ФайлOut.Close();
        }
        static void формированиеСтрокиВывода(int i, int[] B, ref string строка)
        {
            if (i < B.Length)
            {
                строка += " " + B[i];
                формированиеСтрокиВывода(i + 1, B, ref строка);
            }
        }
    }
}
